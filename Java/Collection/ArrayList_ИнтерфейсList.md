# Содержание
+ [Типы коллекций. Интерфейс Collection](../Collection/ТипыКоллекций_ИнтерфейсCollection.md)
+ [ArrayList. Интерфейс List](#list)
+ [ArrayDeque](#arrdeque)
+ + [Queue](#queue)
+ + [Deque](#deque)
+ [LinkedList](../Collection/LinkedList.md)
___
<br>

<a name="list"></a>
# Класс ArrayList и интерфейс List

Для создания простых списков применяется интерфейс `List`, который расширяет функцональность интерфейса `Collection`.

## Конструкторы

```java
ArrayList() // создает пустой список
ArrayList(Collection <? extends E> col) // создает список, в который добавляются все элементы коллекции col.
```

## Основные методы 

+ `void add(int index, E obj)`: добавляет в список по индексу index объект obj

+ `boolean addAll(int index, Collection<? extends E> col)`: добавляет в список по индексу **index** все элементы коллекции **col**. Если в результате добавления список был изменен, то возвращается **true**, иначе возвращается **false**

+ `E get(int index)`: возвращает объект из списка по индексу index

+ `int indexOf(Object obj)`: возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1

+ `int lastIndexOf(Object obj)`: возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1

+ `ListIterator<E> listIterator ()`: возвращает объект ListIterator для обхода элементов списка

+ `static <E> List<E> of(элементы)`: создает из набора элементов объект List

+ `E remove(int index)`: удаляет объект из списка по индексу index, возвращая при этом удаленный объект

+ `E set(int index, E obj)`: присваивает значение объекта obj элементу, который находится по индексу index

+ `void sort(Comparator<? super E> comp)`: сортирует список с помощью компаратора comp

+ `List<E> subList(int start, int end)`: получает набор элементов, которые находятся в списке между индексами **start** и **end**

<br>

Емкость в **ArrayList** представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости **ArrayList** позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.
___
<br><br>

<a name="arrdeque"></a>
# Очереди и класс ArrayDeque


Класс `ArrayDeque<E>` представляет обобщенную двунаправленную очередь, наследуя функционал от класса `AbstractCollection` и применяя интерфейс `Deque`.

## Конструкторы

```Java
ArrayDeque() //создает пустую очередь
ArrayDeque(Collection<? extends E> col) //создает очередь, наполненную элементами из коллекции col
```


Очереди представляют структуру данных, работающую по принципу **FIFO** **(first in - first out)** - чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Также бывают и двунаправленные, в которых можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала.

Классы очередь реализуют специальные интерфейсы `Queue` или `Deque`.

<a name="queue"></a>
# Интерфейс Queue

`Queue<E>` определяет поведение класса в качестве однонаправленной очереди. 
## Основные методы:

+ `E element()`: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean offer(E obj)`: добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `E peek()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E poll()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E remove()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

Все классы, которые реализуют данный интерфейс, будут иметь эти методы

___
<br>


# Интерфейс Deque

`Deque` расширяет интерфейс `Queue` и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, действующий по принципу **LIFO** (последний вошел - первый вышел)

<a name="deque"></a>

## Основные методы:

+ `void addFirst(E obj)`: добавляет элемент в начало очереди

+ `void addLast(E obj)`: добавляет элемент в конец очереди

+ `E getFirst()`: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `E getLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean offerFirst(E obj)`: добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `boolean offerLast(E obj)`: добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `E peekFirst()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`

+ `E peekLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение **null**

+ `E pollFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E pollLast()`: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение **null**

+ `E pop()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `void push(E element)`: добавляет элемент в самое начало очереди

+ `E removeFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `E removeLast()`: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean removeFirstOccurrence(Object obj)`: удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает **true**, иначе возвращает **false**.

+ `boolean removeLastOccurrence(Object obj)`: удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает **true**, иначе возвращает **false**.

> Наличие методов **pop** и **push** позволяет классам, реализующим этот элемент, действовать в качестве стека. Имеющийся функционал позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.
___
<br>









[Вернуться назад](../../README.md)