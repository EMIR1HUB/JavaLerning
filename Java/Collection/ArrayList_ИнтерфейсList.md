# Содержание
+ [Типы коллекций. Интерфейс Collection](../Collection/ТипыКоллекций_ИнтерфейсCollection.md)
+ [ArrayList. Интерфейс List](#list)
+ [ArrayDeque](#arrdeque)
+ + [Queue](#queue)
+ + [Deque](#deque)
+ [LinkedList](#linkedlist)
+ [Set](#set)
+ + [HashSet](#hashset)
+ + [SortedSet](#sortedset)
+ + [NavigableSet](#navset)
+ + [LinkedHashSet](#linkedhashset)
+ + [TreeSet](#treeset)
___
<br>

<a name="list"></a>
# Класс ArrayList и интерфейс List

Для создания простых списков применяется интерфейс `List`, который расширяет функцональность интерфейса `Collection`.

## Конструкторы

```java
ArrayList() // создает пустой список
ArrayList(Collection <? extends E> col) // создает список, в который добавляются все элементы коллекции col.
```

## Основные методы 

+ `void add(int index, E obj)`: добавляет в список по индексу index объект obj

+ `boolean addAll(int index, Collection<? extends E> col)`: добавляет в список по индексу **index** все элементы коллекции **col**. Если в результате добавления список был изменен, то возвращается **true**, иначе возвращается **false**

+ `E get(int index)`: возвращает объект из списка по индексу index

+ `int indexOf(Object obj)`: возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1

+ `int lastIndexOf(Object obj)`: возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1

+ `ListIterator<E> listIterator ()`: возвращает объект ListIterator для обхода элементов списка

+ `static <E> List<E> of(элементы)`: создает из набора элементов объект List

+ `E remove(int index)`: удаляет объект из списка по индексу index, возвращая при этом удаленный объект

+ `E set(int index, E obj)`: присваивает значение объекта obj элементу, который находится по индексу index

+ `void sort(Comparator<? super E> comp)`: сортирует список с помощью компаратора comp

+ `List<E> subList(int start, int end)`: получает набор элементов, которые находятся в списке между индексами **start** и **end**

<br>

Емкость в **ArrayList** представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости **ArrayList** позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.
___
<br><br>

<a name="arrdeque"></a>
# Очереди и класс ArrayDeque


Класс `ArrayDeque<E>` представляет обобщенную двунаправленную очередь, наследуя функционал от класса `AbstractCollection` и применяя интерфейс `Deque`.

## Конструкторы

```Java
ArrayDeque() //создает пустую очередь
ArrayDeque(Collection<? extends E> col) //создает очередь, наполненную элементами из коллекции col
```


Очереди представляют структуру данных, работающую по принципу **FIFO** **(first in - first out)** - чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Также бывают и двунаправленные, в которых можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала.

Классы очередь реализуют специальные интерфейсы `Queue` или `Deque`.

<a name="queue"></a>
# Интерфейс Queue

`Queue<E>` определяет поведение класса в качестве однонаправленной очереди. 
## Основные методы:

+ `E element()`: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean offer(E obj)`: добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `E peek()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E poll()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E remove()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

Все классы, которые реализуют данный интерфейс, будут иметь эти методы

___
<br>

<a name="deque"></a>
# Интерфейс Deque

`Deque` расширяет интерфейс `Queue` и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, действующий по принципу **LIFO** (последний вошел - первый вышел)


## Основные методы:

+ `void addFirst(E obj)`: добавляет элемент в начало очереди

+ `void addLast(E obj)`: добавляет элемент в конец очереди

+ `E getFirst()`: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `E getLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean offerFirst(E obj)`: добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `boolean offerLast(E obj)`: добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает **true**, иначе - **false**

+ `E peekFirst()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`

+ `E peekLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение **null**

+ `E pollFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение **null**

+ `E pollLast()`: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение **null**

+ `E pop()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `void push(E element)`: добавляет элемент в самое начало очереди

+ `E removeFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `E removeLast()`: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение **NoSuchElementException**

+ `boolean removeFirstOccurrence(Object obj)`: удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает **true**, иначе возвращает **false**.

+ `boolean removeLastOccurrence(Object obj)`: удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает **true**, иначе возвращает **false**.

> Наличие методов **pop** и **push** позволяет классам, реализующим этот элемент, действовать в качестве стека. Имеющийся функционал позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.
___
<br>


<a name="linkedlist"></a>
# LinkedList

`LinkedList<E>` - структура связанного списка. Наследуется от класса `AbstractSequentialList` и реализует интерфейсы `List`, `Dequeue`, `Queue`.

## Конструкторы 
```java
LinkedList() // создает пустой список
LinkedList(Collection<? extends E> col) // создает список, в который добавляет все элементы коллекции col
```
## Методы

`LinkedList` содержит все методы, которые определены в интерфейсах [List](#list), [Queue](#queue), [Deque](#deque). Некоторые из них:

+ `addFirst() / offerFirst()`: добавляет элемент в начало списка

+ `addLast() / offerLast()`: добавляет элемент в конец списка

+ `removeFirst() / pollFirst()`: удаляет первый элемент из начала списка

+ `removeLast() / pollLast()`: удаляет последний элемент из конца списка

## Пример

```java
import java.util.LinkedList;
 
public class Program{
      
    public static void main(String[] args) {
          
        LinkedList<String> states = new LinkedList<String>();
          
        states.add("Germany");
        states.addLast("Great Britain"); // добавляем на последнее место
        states.addFirst("Spain"); // добавляем на первое место
        states.add(1, "Italy"); // добавляем элемент по индексу 1
        
        System.out.printf("List has %d elements \n", states.size());
        System.out.println(states.get(1));
        states.set(1, "Portugal");
        for(String state : states){
            System.out.println(state);
        }
        // проверка на наличие элемента в списке
        if(states.contains("Germany")){
            System.out.println("List contains Germany");
        }
          
        states.remove("Germany");
        states.removeFirst(); // удаление первого элемента
          
        LinkedList<Person> people = new LinkedList<Person>();
        people.add(new Person("Mike"));
        people.addFirst(new Person("Tom"));
        people.remove(1); // удаление второго элемента
          
        for(Person p : people){
            System.out.println(p.getName());
        }
        Person first = people.getFirst();
        System.out.println(first.getName()); // вывод первого элемента
    }
}
class Person{    
    private String name;
    public Person(String value){
        name=value;
    }
    String getName(){return name;}
}
```
___
<br>

<a name="set"></a>
# Set

Интерфейс `Set` расширяет интерфейс `Collection` и представляет набор уникальных элементов.

> Каждый элемент хранится только в одном экземпляре, разные реализации `Set` используют разный порядок хранения элементов.

Если порядок хранения важен, применяется `TreeSet`, в котором объекты хранятся отсортированными по возрастанию или с хранением элементов в порядке добавления `LinkedHashSet`.

<br>

<a name="hashset"></a>
# HashSet

`HashSet` представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице.

> Класс `HashSet` не добавляет новых методов, реализуя лишь те, что объявлены в родительских классах и применяемых интерфейсах:

## Создание множества и заполнение элементами

```java
HashSet<String> states = new HashSet<String>(); // Создание множества
states.add("Germany");
states.add("France");
states.add("Italy");
```
## Получение множества | метод **iterator()**

`iterator()` - метод позволяющий получить все множество элементов.

```java
Iterator<String> iterator = states.iterator(); // Создание итератора
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```
## Основные методы
```java
int size() // размер
boolean isEmpty()
boolean contains(Object o)
boolean addAll(Collection c)
Object[] toArray()
boolean remove(Object o)
boolean removeAll(Collection c)
void clear()
```
<br>

<a name="sortedset"></a>
# SortedSet

`SortedSet` предназначен для создания коллекций, который хранят элементы в отсортированном виде (сортировка по возрастанию). **SortedSet** расширяет интерфейс **Set**, поэтому такая коллекция опять же хранит только уникальные значения.

## Методы

+ `E first()`: возвращает первый элемент набора

+ `E last()`: возвращает последний элемент набора

+ `SortedSet<E> headSet(E end)`: возвращает объект **SortedSet**, который содержит все элементы первичного набора до элемента end

+ `SortedSet<E> subSet(E start, E end)`: возвращает объект **SortedSet**, который содержит все элементы первичного набора между элементами start и end

+ `SortedSet<E> tailSet(E start)`: возвращает объект SortedSet, который содержит все элементы первичного набора, начиная с элемента start

<br>

<a name="navset"></a>
# NavigableSet

`NavigableSet` расширяет интерфейс `SortedSet` и позволяет извлекать элементы на основании их значений.

[Методы](https://metanit.com/java/tutorial/5.5.php)

<br>

<a name="linkedhashset"></a>
# LinkedHashSet | Элементы в порядке добавления

Не добавляет новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор. 

<br>


<a name="treeset"></a>
# TreeSet | Элементы отсортированные по возрастанию

Обобщенный класс `TreeSet<E>` представляет структуру данных в виде дерева, в котором все объекты хранятся в отсортированном виде по возрастанию.

```java
Random random = new Random();
SortedSet<Integer> sortedNumbers = new TreeSet<>(); //Создаие TreeSet

for (int i = 0; i < 5; i++) {
    sortedNumbers.add(random.nextInt(10));
}

// Результаты работы
Элементы отсортированы по возрастанию, размер множества меняется, так как повторяющиеся
элементы не добавляются, а игнорируются
[0, 4, 6, 9]
[0, 1, 2, 4, 8]
[2, 3, 9]
```


[Вернуться назад](../../README.md)